// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: indykite/identity/v1beta1/import.proto

package identityv1beta1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ImportUsersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportUsersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportUsersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportUsersRequestMultiError, or nil if none found.
func (m *ImportUsersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportUsersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUsers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  fmt.Sprintf("Users[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  fmt.Sprintf("Users[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch m.HashAlgorithm.(type) {

	case *ImportUsersRequest_Bcrypt:

		if all {
			switch v := interface{}(m.GetBcrypt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Bcrypt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Bcrypt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBcrypt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  "Bcrypt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportUsersRequest_StandardScrypt:

		if all {
			switch v := interface{}(m.GetStandardScrypt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "StandardScrypt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "StandardScrypt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStandardScrypt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  "StandardScrypt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportUsersRequest_Scrypt:

		if all {
			switch v := interface{}(m.GetScrypt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Scrypt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Scrypt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScrypt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  "Scrypt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportUsersRequest_HmacMd5:

		if all {
			switch v := interface{}(m.GetHmacMd5()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "HmacMd5",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "HmacMd5",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHmacMd5()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  "HmacMd5",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportUsersRequest_HmacSha1:

		if all {
			switch v := interface{}(m.GetHmacSha1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "HmacSha1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "HmacSha1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHmacSha1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  "HmacSha1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportUsersRequest_HmacSha512:

		if all {
			switch v := interface{}(m.GetHmacSha512()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "HmacSha512",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "HmacSha512",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHmacSha512()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  "HmacSha512",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportUsersRequest_HmacSha256:

		if all {
			switch v := interface{}(m.GetHmacSha256()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "HmacSha256",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "HmacSha256",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHmacSha256()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  "HmacSha256",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportUsersRequest_Md5:

		if all {
			switch v := interface{}(m.GetMd5()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Md5",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Md5",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMd5()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  "Md5",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportUsersRequest_Pbkdf2Sha256:

		if all {
			switch v := interface{}(m.GetPbkdf2Sha256()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Pbkdf2Sha256",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Pbkdf2Sha256",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPbkdf2Sha256()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  "Pbkdf2Sha256",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportUsersRequest_PbkdfSha1:

		if all {
			switch v := interface{}(m.GetPbkdfSha1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "PbkdfSha1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "PbkdfSha1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPbkdfSha1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  "PbkdfSha1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportUsersRequest_Sha1:

		if all {
			switch v := interface{}(m.GetSha1()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Sha1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Sha1",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSha1()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  "Sha1",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportUsersRequest_Sha256:

		if all {
			switch v := interface{}(m.GetSha256()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Sha256",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Sha256",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSha256()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  "Sha256",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ImportUsersRequest_Sha512:

		if all {
			switch v := interface{}(m.GetSha512()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Sha512",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersRequestValidationError{
						field:  "Sha512",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSha512()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersRequestValidationError{
					field:  "Sha512",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ImportUsersRequestMultiError(errors)
	}

	return nil
}

// ImportUsersRequestMultiError is an error wrapping multiple validation errors
// returned by ImportUsersRequest.ValidateAll() if the designated constraints
// aren't met.
type ImportUsersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportUsersRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportUsersRequestMultiError) AllErrors() []error { return m }

// ImportUsersRequestValidationError is the validation error returned by
// ImportUsersRequest.Validate if the designated constraints aren't met.
type ImportUsersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportUsersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportUsersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportUsersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportUsersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportUsersRequestValidationError) ErrorName() string {
	return "ImportUsersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ImportUsersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportUsersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportUsersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportUsersRequestValidationError{}

// Validate checks the field values on ImportUsersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ImportUsersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportUsersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportUsersResponseMultiError, or nil if none found.
func (m *ImportUsersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportUsersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUsersResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUsersResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUsersResponseValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ImportUsersResponseMultiError(errors)
	}

	return nil
}

// ImportUsersResponseMultiError is an error wrapping multiple validation
// errors returned by ImportUsersResponse.ValidateAll() if the designated
// constraints aren't met.
type ImportUsersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportUsersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportUsersResponseMultiError) AllErrors() []error { return m }

// ImportUsersResponseValidationError is the validation error returned by
// ImportUsersResponse.Validate if the designated constraints aren't met.
type ImportUsersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportUsersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportUsersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportUsersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportUsersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportUsersResponseValidationError) ErrorName() string {
	return "ImportUsersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ImportUsersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportUsersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportUsersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportUsersResponseValidationError{}

// Validate checks the field values on ImportUser with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImportUser) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportUser with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImportUserMultiError, or
// nil if none found.
func (m *ImportUser) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportUser) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	if all {
		switch v := interface{}(m.GetPassword()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportUserValidationError{
					field:  "Password",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportUserValidationError{
					field:  "Password",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPassword()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportUserValidationError{
				field:  "Password",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetProviderUserInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportUserValidationError{
						field:  fmt.Sprintf("ProviderUserInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportUserValidationError{
						field:  fmt.Sprintf("ProviderUserInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportUserValidationError{
					field:  fmt.Sprintf("ProviderUserInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Disabled

	if len(errors) > 0 {
		return ImportUserMultiError(errors)
	}

	return nil
}

// ImportUserMultiError is an error wrapping multiple validation errors
// returned by ImportUser.ValidateAll() if the designated constraints aren't met.
type ImportUserMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportUserMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportUserMultiError) AllErrors() []error { return m }

// ImportUserValidationError is the validation error returned by
// ImportUser.Validate if the designated constraints aren't met.
type ImportUserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportUserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportUserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportUserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportUserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportUserValidationError) ErrorName() string { return "ImportUserValidationError" }

// Error satisfies the builtin error interface
func (e ImportUserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportUserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportUserValidationError{}

// Validate checks the field values on UserMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserMetadataMultiError, or
// nil if none found.
func (m *UserMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *UserMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreationTimestamp

	// no validation rules for LastLogInTimestamp

	// no validation rules for LastRefreshTimestamp

	if len(errors) > 0 {
		return UserMetadataMultiError(errors)
	}

	return nil
}

// UserMetadataMultiError is an error wrapping multiple validation errors
// returned by UserMetadata.ValidateAll() if the designated constraints aren't met.
type UserMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserMetadataMultiError) AllErrors() []error { return m }

// UserMetadataValidationError is the validation error returned by
// UserMetadata.Validate if the designated constraints aren't met.
type UserMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserMetadataValidationError) ErrorName() string { return "UserMetadataValidationError" }

// Error satisfies the builtin error interface
func (e UserMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserMetadataValidationError{}

// Validate checks the field values on Email with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Email) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Email with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EmailMultiError, or nil if none found.
func (m *Email) ValidateAll() error {
	return m.validate(true)
}

func (m *Email) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Email

	// no validation rules for Verified

	if len(errors) > 0 {
		return EmailMultiError(errors)
	}

	return nil
}

// EmailMultiError is an error wrapping multiple validation errors returned by
// Email.ValidateAll() if the designated constraints aren't met.
type EmailMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmailMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmailMultiError) AllErrors() []error { return m }

// EmailValidationError is the validation error returned by Email.Validate if
// the designated constraints aren't met.
type EmailValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmailValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmailValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmailValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmailValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmailValidationError) ErrorName() string { return "EmailValidationError" }

// Error satisfies the builtin error interface
func (e EmailValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmail.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmailValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmailValidationError{}

// Validate checks the field values on Mobile with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Mobile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Mobile with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MobileMultiError, or nil if none found.
func (m *Mobile) ValidateAll() error {
	return m.validate(true)
}

func (m *Mobile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mobile

	// no validation rules for Verified

	if len(errors) > 0 {
		return MobileMultiError(errors)
	}

	return nil
}

// MobileMultiError is an error wrapping multiple validation errors returned by
// Mobile.ValidateAll() if the designated constraints aren't met.
type MobileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MobileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MobileMultiError) AllErrors() []error { return m }

// MobileValidationError is the validation error returned by Mobile.Validate if
// the designated constraints aren't met.
type MobileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MobileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MobileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MobileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MobileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MobileValidationError) ErrorName() string { return "MobileValidationError" }

// Error satisfies the builtin error interface
func (e MobileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMobile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MobileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MobileValidationError{}

// Validate checks the field values on PasswordCredential with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PasswordCredential) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PasswordCredential with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PasswordCredentialMultiError, or nil if none found.
func (m *PasswordCredential) ValidateAll() error {
	return m.validate(true)
}

func (m *PasswordCredential) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Uid.(type) {

	case *PasswordCredential_Email:

		if all {
			switch v := interface{}(m.GetEmail()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PasswordCredentialValidationError{
						field:  "Email",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PasswordCredentialValidationError{
						field:  "Email",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEmail()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PasswordCredentialValidationError{
					field:  "Email",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PasswordCredential_Mobile:

		if all {
			switch v := interface{}(m.GetMobile()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PasswordCredentialValidationError{
						field:  "Mobile",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PasswordCredentialValidationError{
						field:  "Mobile",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMobile()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PasswordCredentialValidationError{
					field:  "Mobile",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PasswordCredential_UserName:
		// no validation rules for UserName

	}

	switch m.Password.(type) {

	case *PasswordCredential_Value:
		// no validation rules for Value

	case *PasswordCredential_Hash:

		if all {
			switch v := interface{}(m.GetHash()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PasswordCredentialValidationError{
						field:  "Hash",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PasswordCredentialValidationError{
						field:  "Hash",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHash()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PasswordCredentialValidationError{
					field:  "Hash",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PasswordCredentialMultiError(errors)
	}

	return nil
}

// PasswordCredentialMultiError is an error wrapping multiple validation errors
// returned by PasswordCredential.ValidateAll() if the designated constraints
// aren't met.
type PasswordCredentialMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PasswordCredentialMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PasswordCredentialMultiError) AllErrors() []error { return m }

// PasswordCredentialValidationError is the validation error returned by
// PasswordCredential.Validate if the designated constraints aren't met.
type PasswordCredentialValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PasswordCredentialValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PasswordCredentialValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PasswordCredentialValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PasswordCredentialValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PasswordCredentialValidationError) ErrorName() string {
	return "PasswordCredentialValidationError"
}

// Error satisfies the builtin error interface
func (e PasswordCredentialValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPasswordCredential.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PasswordCredentialValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PasswordCredentialValidationError{}

// Validate checks the field values on PasswordHash with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PasswordHash) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PasswordHash with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PasswordHashMultiError, or
// nil if none found.
func (m *PasswordHash) ValidateAll() error {
	return m.validate(true)
}

func (m *PasswordHash) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PasswordHash

	// no validation rules for Salt

	if len(errors) > 0 {
		return PasswordHashMultiError(errors)
	}

	return nil
}

// PasswordHashMultiError is an error wrapping multiple validation errors
// returned by PasswordHash.ValidateAll() if the designated constraints aren't met.
type PasswordHashMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PasswordHashMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PasswordHashMultiError) AllErrors() []error { return m }

// PasswordHashValidationError is the validation error returned by
// PasswordHash.Validate if the designated constraints aren't met.
type PasswordHashValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PasswordHashValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PasswordHashValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PasswordHashValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PasswordHashValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PasswordHashValidationError) ErrorName() string { return "PasswordHashValidationError" }

// Error satisfies the builtin error interface
func (e PasswordHashValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPasswordHash.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PasswordHashValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PasswordHashValidationError{}

// Validate checks the field values on UserProvider with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserProvider) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserProvider with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserProviderMultiError, or
// nil if none found.
func (m *UserProvider) ValidateAll() error {
	return m.validate(true)
}

func (m *UserProvider) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for ProviderId

	// no validation rules for Email

	// no validation rules for DisplayName

	// no validation rules for PhotoUrl

	if len(errors) > 0 {
		return UserProviderMultiError(errors)
	}

	return nil
}

// UserProviderMultiError is an error wrapping multiple validation errors
// returned by UserProvider.ValidateAll() if the designated constraints aren't met.
type UserProviderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserProviderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserProviderMultiError) AllErrors() []error { return m }

// UserProviderValidationError is the validation error returned by
// UserProvider.Validate if the designated constraints aren't met.
type UserProviderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserProviderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserProviderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserProviderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserProviderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserProviderValidationError) ErrorName() string { return "UserProviderValidationError" }

// Error satisfies the builtin error interface
func (e UserProviderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserProvider.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserProviderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserProviderValidationError{}

// Validate checks the field values on Bcrypt with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Bcrypt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Bcrypt with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BcryptMultiError, or nil if none found.
func (m *Bcrypt) ValidateAll() error {
	return m.validate(true)
}

func (m *Bcrypt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BcryptMultiError(errors)
	}

	return nil
}

// BcryptMultiError is an error wrapping multiple validation errors returned by
// Bcrypt.ValidateAll() if the designated constraints aren't met.
type BcryptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BcryptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BcryptMultiError) AllErrors() []error { return m }

// BcryptValidationError is the validation error returned by Bcrypt.Validate if
// the designated constraints aren't met.
type BcryptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BcryptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BcryptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BcryptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BcryptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BcryptValidationError) ErrorName() string { return "BcryptValidationError" }

// Error satisfies the builtin error interface
func (e BcryptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBcrypt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BcryptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BcryptValidationError{}

// Validate checks the field values on StandardScrypt with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StandardScrypt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StandardScrypt with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StandardScryptMultiError,
// or nil if none found.
func (m *StandardScrypt) ValidateAll() error {
	return m.validate(true)
}

func (m *StandardScrypt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BlockSize

	// no validation rules for DerivedKeyLength

	// no validation rules for MemoryCost

	// no validation rules for Parallelization

	if len(errors) > 0 {
		return StandardScryptMultiError(errors)
	}

	return nil
}

// StandardScryptMultiError is an error wrapping multiple validation errors
// returned by StandardScrypt.ValidateAll() if the designated constraints
// aren't met.
type StandardScryptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StandardScryptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StandardScryptMultiError) AllErrors() []error { return m }

// StandardScryptValidationError is the validation error returned by
// StandardScrypt.Validate if the designated constraints aren't met.
type StandardScryptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StandardScryptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StandardScryptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StandardScryptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StandardScryptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StandardScryptValidationError) ErrorName() string { return "StandardScryptValidationError" }

// Error satisfies the builtin error interface
func (e StandardScryptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStandardScrypt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StandardScryptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StandardScryptValidationError{}

// Validate checks the field values on Scrypt with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Scrypt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Scrypt with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ScryptMultiError, or nil if none found.
func (m *Scrypt) ValidateAll() error {
	return m.validate(true)
}

func (m *Scrypt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for SaltSeparator

	// no validation rules for Rounds

	// no validation rules for MemoryCost

	if len(errors) > 0 {
		return ScryptMultiError(errors)
	}

	return nil
}

// ScryptMultiError is an error wrapping multiple validation errors returned by
// Scrypt.ValidateAll() if the designated constraints aren't met.
type ScryptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScryptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScryptMultiError) AllErrors() []error { return m }

// ScryptValidationError is the validation error returned by Scrypt.Validate if
// the designated constraints aren't met.
type ScryptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScryptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScryptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScryptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScryptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScryptValidationError) ErrorName() string { return "ScryptValidationError" }

// Error satisfies the builtin error interface
func (e ScryptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScrypt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScryptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScryptValidationError{}

// Validate checks the field values on HMACMD5 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HMACMD5) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HMACMD5 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in HMACMD5MultiError, or nil if none found.
func (m *HMACMD5) ValidateAll() error {
	return m.validate(true)
}

func (m *HMACMD5) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return HMACMD5MultiError(errors)
	}

	return nil
}

// HMACMD5MultiError is an error wrapping multiple validation errors returned
// by HMACMD5.ValidateAll() if the designated constraints aren't met.
type HMACMD5MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HMACMD5MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HMACMD5MultiError) AllErrors() []error { return m }

// HMACMD5ValidationError is the validation error returned by HMACMD5.Validate
// if the designated constraints aren't met.
type HMACMD5ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HMACMD5ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HMACMD5ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HMACMD5ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HMACMD5ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HMACMD5ValidationError) ErrorName() string { return "HMACMD5ValidationError" }

// Error satisfies the builtin error interface
func (e HMACMD5ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHMACMD5.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HMACMD5ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HMACMD5ValidationError{}

// Validate checks the field values on HMACSHA1 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HMACSHA1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HMACSHA1 with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HMACSHA1MultiError, or nil
// if none found.
func (m *HMACSHA1) ValidateAll() error {
	return m.validate(true)
}

func (m *HMACSHA1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return HMACSHA1MultiError(errors)
	}

	return nil
}

// HMACSHA1MultiError is an error wrapping multiple validation errors returned
// by HMACSHA1.ValidateAll() if the designated constraints aren't met.
type HMACSHA1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HMACSHA1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HMACSHA1MultiError) AllErrors() []error { return m }

// HMACSHA1ValidationError is the validation error returned by
// HMACSHA1.Validate if the designated constraints aren't met.
type HMACSHA1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HMACSHA1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HMACSHA1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HMACSHA1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HMACSHA1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HMACSHA1ValidationError) ErrorName() string { return "HMACSHA1ValidationError" }

// Error satisfies the builtin error interface
func (e HMACSHA1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHMACSHA1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HMACSHA1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HMACSHA1ValidationError{}

// Validate checks the field values on HMACSHA512 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HMACSHA512) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HMACSHA512 with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HMACSHA512MultiError, or
// nil if none found.
func (m *HMACSHA512) ValidateAll() error {
	return m.validate(true)
}

func (m *HMACSHA512) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return HMACSHA512MultiError(errors)
	}

	return nil
}

// HMACSHA512MultiError is an error wrapping multiple validation errors
// returned by HMACSHA512.ValidateAll() if the designated constraints aren't met.
type HMACSHA512MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HMACSHA512MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HMACSHA512MultiError) AllErrors() []error { return m }

// HMACSHA512ValidationError is the validation error returned by
// HMACSHA512.Validate if the designated constraints aren't met.
type HMACSHA512ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HMACSHA512ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HMACSHA512ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HMACSHA512ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HMACSHA512ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HMACSHA512ValidationError) ErrorName() string { return "HMACSHA512ValidationError" }

// Error satisfies the builtin error interface
func (e HMACSHA512ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHMACSHA512.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HMACSHA512ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HMACSHA512ValidationError{}

// Validate checks the field values on HMACSHA256 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HMACSHA256) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HMACSHA256 with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HMACSHA256MultiError, or
// nil if none found.
func (m *HMACSHA256) ValidateAll() error {
	return m.validate(true)
}

func (m *HMACSHA256) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return HMACSHA256MultiError(errors)
	}

	return nil
}

// HMACSHA256MultiError is an error wrapping multiple validation errors
// returned by HMACSHA256.ValidateAll() if the designated constraints aren't met.
type HMACSHA256MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HMACSHA256MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HMACSHA256MultiError) AllErrors() []error { return m }

// HMACSHA256ValidationError is the validation error returned by
// HMACSHA256.Validate if the designated constraints aren't met.
type HMACSHA256ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HMACSHA256ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HMACSHA256ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HMACSHA256ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HMACSHA256ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HMACSHA256ValidationError) ErrorName() string { return "HMACSHA256ValidationError" }

// Error satisfies the builtin error interface
func (e HMACSHA256ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHMACSHA256.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HMACSHA256ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HMACSHA256ValidationError{}

// Validate checks the field values on MD5 with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *MD5) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MD5 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MD5MultiError, or nil if none found.
func (m *MD5) ValidateAll() error {
	return m.validate(true)
}

func (m *MD5) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rounds

	if len(errors) > 0 {
		return MD5MultiError(errors)
	}

	return nil
}

// MD5MultiError is an error wrapping multiple validation errors returned by
// MD5.ValidateAll() if the designated constraints aren't met.
type MD5MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MD5MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MD5MultiError) AllErrors() []error { return m }

// MD5ValidationError is the validation error returned by MD5.Validate if the
// designated constraints aren't met.
type MD5ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MD5ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MD5ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MD5ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MD5ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MD5ValidationError) ErrorName() string { return "MD5ValidationError" }

// Error satisfies the builtin error interface
func (e MD5ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMD5.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MD5ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MD5ValidationError{}

// Validate checks the field values on PBKDF2SHA256 with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PBKDF2SHA256) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PBKDF2SHA256 with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PBKDF2SHA256MultiError, or
// nil if none found.
func (m *PBKDF2SHA256) ValidateAll() error {
	return m.validate(true)
}

func (m *PBKDF2SHA256) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rounds

	if len(errors) > 0 {
		return PBKDF2SHA256MultiError(errors)
	}

	return nil
}

// PBKDF2SHA256MultiError is an error wrapping multiple validation errors
// returned by PBKDF2SHA256.ValidateAll() if the designated constraints aren't met.
type PBKDF2SHA256MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PBKDF2SHA256MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PBKDF2SHA256MultiError) AllErrors() []error { return m }

// PBKDF2SHA256ValidationError is the validation error returned by
// PBKDF2SHA256.Validate if the designated constraints aren't met.
type PBKDF2SHA256ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PBKDF2SHA256ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PBKDF2SHA256ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PBKDF2SHA256ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PBKDF2SHA256ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PBKDF2SHA256ValidationError) ErrorName() string { return "PBKDF2SHA256ValidationError" }

// Error satisfies the builtin error interface
func (e PBKDF2SHA256ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPBKDF2SHA256.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PBKDF2SHA256ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PBKDF2SHA256ValidationError{}

// Validate checks the field values on PBKDFSHA1 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PBKDFSHA1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PBKDFSHA1 with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PBKDFSHA1MultiError, or nil
// if none found.
func (m *PBKDFSHA1) ValidateAll() error {
	return m.validate(true)
}

func (m *PBKDFSHA1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rounds

	if len(errors) > 0 {
		return PBKDFSHA1MultiError(errors)
	}

	return nil
}

// PBKDFSHA1MultiError is an error wrapping multiple validation errors returned
// by PBKDFSHA1.ValidateAll() if the designated constraints aren't met.
type PBKDFSHA1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PBKDFSHA1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PBKDFSHA1MultiError) AllErrors() []error { return m }

// PBKDFSHA1ValidationError is the validation error returned by
// PBKDFSHA1.Validate if the designated constraints aren't met.
type PBKDFSHA1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PBKDFSHA1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PBKDFSHA1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PBKDFSHA1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PBKDFSHA1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PBKDFSHA1ValidationError) ErrorName() string { return "PBKDFSHA1ValidationError" }

// Error satisfies the builtin error interface
func (e PBKDFSHA1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPBKDFSHA1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PBKDFSHA1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PBKDFSHA1ValidationError{}

// Validate checks the field values on SHA1 with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *SHA1) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SHA1 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SHA1MultiError, or nil if none found.
func (m *SHA1) ValidateAll() error {
	return m.validate(true)
}

func (m *SHA1) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rounds

	if len(errors) > 0 {
		return SHA1MultiError(errors)
	}

	return nil
}

// SHA1MultiError is an error wrapping multiple validation errors returned by
// SHA1.ValidateAll() if the designated constraints aren't met.
type SHA1MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SHA1MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SHA1MultiError) AllErrors() []error { return m }

// SHA1ValidationError is the validation error returned by SHA1.Validate if the
// designated constraints aren't met.
type SHA1ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SHA1ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SHA1ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SHA1ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SHA1ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SHA1ValidationError) ErrorName() string { return "SHA1ValidationError" }

// Error satisfies the builtin error interface
func (e SHA1ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSHA1.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SHA1ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SHA1ValidationError{}

// Validate checks the field values on SHA256 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SHA256) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SHA256 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SHA256MultiError, or nil if none found.
func (m *SHA256) ValidateAll() error {
	return m.validate(true)
}

func (m *SHA256) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rounds

	if len(errors) > 0 {
		return SHA256MultiError(errors)
	}

	return nil
}

// SHA256MultiError is an error wrapping multiple validation errors returned by
// SHA256.ValidateAll() if the designated constraints aren't met.
type SHA256MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SHA256MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SHA256MultiError) AllErrors() []error { return m }

// SHA256ValidationError is the validation error returned by SHA256.Validate if
// the designated constraints aren't met.
type SHA256ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SHA256ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SHA256ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SHA256ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SHA256ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SHA256ValidationError) ErrorName() string { return "SHA256ValidationError" }

// Error satisfies the builtin error interface
func (e SHA256ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSHA256.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SHA256ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SHA256ValidationError{}

// Validate checks the field values on SHA512 with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SHA512) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SHA512 with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SHA512MultiError, or nil if none found.
func (m *SHA512) ValidateAll() error {
	return m.validate(true)
}

func (m *SHA512) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Rounds

	if len(errors) > 0 {
		return SHA512MultiError(errors)
	}

	return nil
}

// SHA512MultiError is an error wrapping multiple validation errors returned by
// SHA512.ValidateAll() if the designated constraints aren't met.
type SHA512MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SHA512MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SHA512MultiError) AllErrors() []error { return m }

// SHA512ValidationError is the validation error returned by SHA512.Validate if
// the designated constraints aren't met.
type SHA512ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SHA512ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SHA512ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SHA512ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SHA512ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SHA512ValidationError) ErrorName() string { return "SHA512ValidationError" }

// Error satisfies the builtin error interface
func (e SHA512ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSHA512.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SHA512ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SHA512ValidationError{}

// Validate checks the field values on ImportUsersResponse_ImportUsersError
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ImportUsersResponse_ImportUsersError) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportUsersResponse_ImportUsersError
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ImportUsersResponse_ImportUsersErrorMultiError, or nil if none found.
func (m *ImportUsersResponse_ImportUsersError) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportUsersResponse_ImportUsersError) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return ImportUsersResponse_ImportUsersErrorMultiError(errors)
	}

	return nil
}

// ImportUsersResponse_ImportUsersErrorMultiError is an error wrapping multiple
// validation errors returned by
// ImportUsersResponse_ImportUsersError.ValidateAll() if the designated
// constraints aren't met.
type ImportUsersResponse_ImportUsersErrorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportUsersResponse_ImportUsersErrorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportUsersResponse_ImportUsersErrorMultiError) AllErrors() []error { return m }

// ImportUsersResponse_ImportUsersErrorValidationError is the validation error
// returned by ImportUsersResponse_ImportUsersError.Validate if the designated
// constraints aren't met.
type ImportUsersResponse_ImportUsersErrorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportUsersResponse_ImportUsersErrorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportUsersResponse_ImportUsersErrorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportUsersResponse_ImportUsersErrorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportUsersResponse_ImportUsersErrorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportUsersResponse_ImportUsersErrorValidationError) ErrorName() string {
	return "ImportUsersResponse_ImportUsersErrorValidationError"
}

// Error satisfies the builtin error interface
func (e ImportUsersResponse_ImportUsersErrorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportUsersResponse_ImportUsersError.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportUsersResponse_ImportUsersErrorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportUsersResponse_ImportUsersErrorValidationError{}

// Validate checks the field values on ImportUsersResponse_ImportUserResult
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ImportUsersResponse_ImportUserResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportUsersResponse_ImportUserResult
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ImportUsersResponse_ImportUserResultMultiError, or nil if none found.
func (m *ImportUsersResponse_ImportUserResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportUsersResponse_ImportUserResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportUsersResponse_ImportUserResultValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportUsersResponse_ImportUserResultValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportUsersResponse_ImportUserResultValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ImportUsersResponse_ImportUserResultMultiError(errors)
	}

	return nil
}

// ImportUsersResponse_ImportUserResultMultiError is an error wrapping multiple
// validation errors returned by
// ImportUsersResponse_ImportUserResult.ValidateAll() if the designated
// constraints aren't met.
type ImportUsersResponse_ImportUserResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportUsersResponse_ImportUserResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportUsersResponse_ImportUserResultMultiError) AllErrors() []error { return m }

// ImportUsersResponse_ImportUserResultValidationError is the validation error
// returned by ImportUsersResponse_ImportUserResult.Validate if the designated
// constraints aren't met.
type ImportUsersResponse_ImportUserResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportUsersResponse_ImportUserResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportUsersResponse_ImportUserResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportUsersResponse_ImportUserResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportUsersResponse_ImportUserResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportUsersResponse_ImportUserResultValidationError) ErrorName() string {
	return "ImportUsersResponse_ImportUserResultValidationError"
}

// Error satisfies the builtin error interface
func (e ImportUsersResponse_ImportUserResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportUsersResponse_ImportUserResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportUsersResponse_ImportUserResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportUsersResponse_ImportUserResultValidationError{}
